defmodule MortalDrinksElixir.Logic do
  @moduledoc """
  A traceful implementation of MicroKanren.

  Generated by Gemini, required mannual review and check.
  """

  # --- Data Structures ---
  defmodule Var do
    defstruct [:id]
    # 为了让日志更好看，实现 String.Chars 协议
    defimpl String.Chars do
      def to_string(%{id: id}), do: "?#{id}"
    end
  end

  defmodule State do
    defstruct subst: %{}, counter: 0, pid: nil
  end

  # --- Core Logic ---

  def walk(%Var{} = u, subst) do
    case Map.fetch(subst, u) do
      {:ok, v} -> walk(v, subst)
      :error -> u
    end
  end
  def walk(u, _), do: u

  def unify(u, v, %State{subst: s, pid: pid} = state) do
    u_val = walk(u, s)
    v_val = walk(v, s)

    result = do_unify(u_val, v_val, s)

    # 遥测：发送思维脉冲
    if pid do
      status = if result, do: :ok, else: :fail
      # 发送原始数据，让 View 层去格式化
      send(pid, {:logic_trace, status, u_val, v_val})
    end

    case result do
      nil -> nil
      new_subst -> %{state | subst: new_subst}
    end
  end

  defp do_unify(u, v, s) when u == v, do: s
  defp do_unify(%Var{} = u, v, s), do: Map.put(s, u, v)
  defp do_unify(u, %Var{} = v, s), do: Map.put(s, v, u)
  defp do_unify([u | us], [v | vs], s) do
    case do_unify(u, v, s) do
      nil -> nil
      s_prime -> do_unify(us, vs, s_prime)
    end
  end
  defp do_unify(_, _, _), do: nil

  # --- Goals (Constructors) ---

  # eq 返回一个 Goal (fn state -> stream)
  def eq(u, v) do
    fn state ->
      case unify(u, v, state) do
        nil -> [] # 失败返回空流
        new_state -> [new_state] # 成功返回包含新状态的流
      end
    end
  end

  # conj 返回一个 Goal
  # 它执行 g1，得到状态流，然后对流中的每个状态执行 g2
  def conj(g1, g2) do
    fn state ->
      state
      |> g1.() # 执行第一个目标
      |> Stream.flat_map(g2) # 将结果流传递给第二个目标
    end
  end

  # call_fresh 负责引入逻辑变量
  def call_fresh(f) do
    fn %State{counter: c} = s ->
      # 1. 创建新变量
      v = %Var{id: c}
      # 2. 获取用户闭包中的 Goal (f.(v) 返回的是 Goal)
      goal = f.(v)
      # 3. 更新计数器
      new_state = %{s | counter: c + 1}
      # 4. === 关键修正 ===
      # 必须在这里调用 goal 并传入 state，才能返回 Stream
      goal.(new_state)
    end
  end

  # --- Runner ---

  def run(query_block) do
    observer = self()
    empty = %State{pid: observer, counter: 0}

    # 1. 用 call_fresh 包装用户的查询块，以生成初始变量 q
    # start_goal 此时是一个 Goal 函数
    start_goal = call_fresh(fn q ->
      query_block.(q)
    end)

    # 2. === 关键修正 ===
    # 将初始状态传入 Goal 函数，从而启动整个链式反应，得到 Stream
    stream = start_goal.(empty)

    # 3. 消费 Stream，强制执行
    Enum.to_list(stream)
  end
end
